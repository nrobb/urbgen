<!DOCTYPE html>
  <head>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/UrbGen.js"></script>
    <script src="js/dat.gui.min.js"></script>
    <script src="js/FileSaver.js"></script>
  </head>
<body>
<script>


	function exportGeometry () {
    var output = gen.OBJData();
		var blob = new Blob( [ output ], { type: 'text/plain' } );
		var objectURL = URL.createObjectURL( blob );
		var date = new Date();
		var timeStamp = date.getTime();
		var fileName = "urbgen_model_" + timeStamp +".obj";
		saveAs(blob, fileName);
	};
	
	function exportParamaters() {
	  var output = gen.paramData();
	  var blob = new Blob([output], {type: 'text/plain'});
		var date = new Date();
		var timeStamp = date.getTime();
		var fileName = "urbgen_model_" + timeStamp +".txt";
		saveAs(blob, fileName);
	}
	
	var updateFcts	= [];
	var scene	= new THREE.Scene();
	scene.fog	= new THREE.FogExp2( 0xd0e0f0, 0.002 );
	// add a renderer
	var renderer	= new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setClearColor(0xffffff, 1);
	document.body.appendChild( renderer.domElement );
	// add a camera
	var camera	= new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 2000);
	// add a light
	var light	= new THREE.HemisphereLight( 0xfffff0, 0x101020, 1.25 );
	light.position.set( 0.75, 1, 0.25 );
	scene.add( light );

  // set up city
  var gen = new URBGEN.Generator();
  var cityGeom;
  var cityMesh;
  
  // set up GUI
      window.onLoad = function() {
        var gui = new dat.GUI();
        gui.width = 300;
        gui.add(gen, "cityWidth", 400, 1500).listen();
        gui.add(gen, "cityDepth", 400, 1500).listen();
        gui.add(gen, "blockSize", 15000, 50000).listen();
        gui.add(gen, "streetWidth", 10, 30).listen();
        gui.add(gen, "globalAngle", 0, 1).listen();
        gui.add(gen, "localGrids", 0, 1).listen();
        gui.add(gen, "throughRoads", 0, 50).listen();
        gui.add(gen, "randomSeed", 0, 1).listen();
        gui.add(this, "update").listen();
        gui.add(this, "random").listen();
        gui.add(this, "exportOBJ");
        gui.add(this, "exportParams");
        this.update();
      };
  window.exportParams = function() {
    exportParamaters();
  }
  window.exportOBJ = function() {
    exportGeometry();
  };
  
  window.random = function() {
    gen.initRandom();
    gen.generate();
    loadCity();
  };
  
  window.update = function() {
    var d = new Date();
    var start = d.getTime();
    gen.init();
    gen.generate();
    d = new Date();
    var end = d.getTime();
    var elapsed = (end - start) / 1000;
    console.log("City generated in " + elapsed + " seconds");
    console.log("City contains " + gen.city.getPlots().length + " plots");
    loadCity();
  };
  window.onLoad();

  function loadCity() {
    // Remove the current city
    scene.remove(cityMesh);
    // Get a geometry representing the buildings
    cityGeom = getCity3D(gen.city.getPlots());
    // make a mesh from the geometry
    cityMesh = THREE.SceneUtils.createMultiMaterialObject(cityGeom,
      [new THREE.MeshLambertMaterial({color: 0xffffff}),
      new THREE.MeshBasicMaterial({color: 0x000000,
      wireframe: true})]);
    // Position the mesh
    cityMesh.rotation.x = -90 * Math.PI / 180;
    var maxX = 0;
    var maxZ = 0;
    for (var i = 0; i < cityGeom.vertices.length; i++) {
      if (cityGeom.vertices[i].x > maxX) maxX = cityGeom.vertices[i].x;
      if (cityGeom.vertices[i].z > maxZ) maxZ = cityGeom.vertices[i].z;
    }
    cityMesh.position.x = -maxX / 2;
    cityMesh.position.z = maxZ * 7;
    cityMesh.position.y = 0;
    // Add the mesh to the scene
    scene.add(cityMesh)
  }
  
  function getCity3D(plots) {
    var cityGeom = new THREE.Geometry();
    // Add each building to the geometry
    for (var j = 0; j < plots.length; j++) {
      // get the plot
      var plot = gen.buildThreeShape(plots[j].poly, new THREE.Shape());
      // set the extrusion settings
      var extrusionSettings = {bevelEnabled: false, amount: plots[j].height};
      // get the building geometry
      var geom = new THREE.ExtrudeGeometry(plot, extrusionSettings);
      cityGeom.merge(geom);
    }
    // return the city
    return cityGeom;
  };


	
	// camera controls
	camera.position.x = 0;
	camera.position.z = 0;
	camera.position.y = 600;
	var controls	= new THREE.OrbitControls( camera, renderer.domElement);
	updateFcts.push(function(delta, now){
		controls.update( delta );
	});
	

  // render
	updateFcts.push(function(){
		renderer.render( scene, camera );
	});
	
	// animation loop
	var lastTimeMsec = null;
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60;
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec);
		lastTimeMsec	= nowMsec;
		// call each update function
		updateFcts.forEach(function(updateFn) {
			updateFn(deltaMsec/1000, nowMsec/1000)
		});
	});
	
</script>
</body>
</html>
