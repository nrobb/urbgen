<!DOCTYPE html>
  <head>
    <script src="js/three.min.js"></script>
    <script src="js/OBJExporter.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/UrbGen.js"></script>
    <script src="js/UrbGenDemo.js"></script>
    <script src="js/dat.gui.min.js"></script>
  </head>
<body>
<script>

// testing save function
	function exportGeometry () {
    var geom = gen.geometry;
    var vertices = geom.vertices;
    var faces = geom.faces;
    var output = "";
    for (var v = 0; v < vertices.length; v++) {
      output += "v " + vertices[v][0] + " " + vertices[v][1] + " " + vertices[v][2] + '\n';
    }
    for (var f = 0; f < faces.length; f++) {
      output += "f " + faces[f][0] + " " + faces[f][1] + " " + faces[f][2] + '\n';
    }

		var blob = new Blob( [ output ], { type: 'text/plain' } );
		var objectURL = URL.createObjectURL( blob );
		
		window.open( objectURL, '_blank' );
		window.focus();

	};
// end test save function helper

	var updateFcts	= [];
	var scene	= new THREE.Scene();
	scene.fog	= new THREE.FogExp2( 0xd0e0f0, 0.002 );
	// add a renderer
	var renderer	= new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setClearColor(0xffffff, 1);
	document.body.appendChild( renderer.domElement );
	// add a camera
	var camera	= new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 2000);
	// add a light
	var light	= new THREE.HemisphereLight( 0xfffff0, 0x101020, 1.25 );
	light.position.set( 0.75, 1, 0.25 );
	scene.add( light );

  // set up city
  var gen = new URBGEN.Generator();
  var cityGeom;
  var city;
  // set up GUI
      window.onLoad = function() {
        var gui = new dat.GUI();
        gui.width = 300;
        gui.add(gen, "regularity1", 0.5, 0.8).listen();
        gui.add(gen, "regularity2", 0.5, 0.8).listen();
        gui.add(gen, "blockSize", 10000, 30000).listen();
        gui.add(gen, "width", 200, window.innerWidth * 0.95).listen();
        gui.add(gen, "depth", 200, window.innerHeight * 0.95).listen();
        gui.add(gen, "minEdgeLength", 40, 50).listen();
        gui.add(gen, "gridThreshold", 0, 1).listen();
        gui.add(gen, "throughRoadStagger", 0, 50).listen();
        gui.add(this, "generateWithParams").listen();
        gui.add(this, "generateRandom").listen();
        gui.add(this, "exportObj");
        this.generateWithParams();
      };
  
  window.exportObj = function() {
    exportGeometry();
  };
  
  window.generateRandom = function() {
    gen.initRandom();
    gen.generate();
    loadCity();
  };
  
  window.generateWithParams = function() {
    gen.init();
    gen.generate();
    loadCity();
  };
  window.onLoad();
  
  function loadCity() {
    scene.remove(city);
    cityGeom = UGDEMO.getCity3D(gen.buildings);
    city = THREE.SceneUtils.createMultiMaterialObject(cityGeom,
      [new THREE.MeshLambertMaterial({color: 0xffffff}),
      new THREE.MeshBasicMaterial({color: 0x000000,
      wireframe: true})]);
    city.rotation.x = -90 * Math.PI / 180;
    var maxX = 0;
    var maxZ = 0;
    for (var i = 0; i < cityGeom.vertices.length; i++) {
      if (cityGeom.vertices[i].x > maxX) maxX = cityGeom.vertices[i].x;
      if (cityGeom.vertices[i].z > maxZ) maxZ = cityGeom.vertices[i].z;
    }
    console.debug(maxX + ", " + maxZ)
    city.position.x = -maxX / 2;
    city.position.z = maxZ * 7;
    city.position.y = 0;
    scene.add(city)
    //camera.lookAt(city);
  }


	
	// camera controls
	camera.position.x = 0;
	camera.position.z = 0;
	camera.position.y = 600;
	var controls	= new THREE.OrbitControls( camera, renderer.domElement);
	updateFcts.push(function(delta, now){
		controls.update( delta );
	});
	

  // render
	updateFcts.push(function(){
		renderer.render( scene, camera );
	});
	
	// animation loop
	var lastTimeMsec = null;
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60;
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec);
		lastTimeMsec	= nowMsec;
		// call each update function
		updateFcts.forEach(function(updateFn) {
			updateFn(deltaMsec/1000, nowMsec/1000)
		});
	});
</script>
</body>
</html>
