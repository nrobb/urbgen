<!DOCTYPE html>
  <head>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/UrbGen.js"></script>
    <script src="js/UrbGenDemo.js"></script>
    <script src="js/dat.gui.min.js"></script>
  </head>
<body>
<script>

// testing save function
	function exportGeometry () {
	  //TODO add this into URBGEN
    var geom = gen.geometry;
    var vertices = geom.vertices;
    var faces = geom.faces;
    var output = "";
    for (var v = 0; v < vertices.length; v++) {
      output += "v " + vertices[v][0] + " " + vertices[v][1] + " " + vertices[v][2] + '\n';
    }
    for (var f = 0; f < faces.length; f++) {
      output += "f " + faces[f][0] + " " + faces[f][1] + " " + faces[f][2] + '\n';
    }

		var blob = new Blob( [ output ], { type: 'text/plain' } );
		var objectURL = URL.createObjectURL( blob );
		
		window.open( objectURL, '_blank' );
		window.focus();

	};
// end test save function helper

	var updateFcts	= [];
	var scene	= new THREE.Scene();
	scene.fog	= new THREE.FogExp2( 0xd0e0f0, 0.002 );
	// add a renderer
	var renderer	= new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setClearColor(0xffffff, 1);
	document.body.appendChild( renderer.domElement );
	// add a camera
	var camera	= new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 2000);
	// add a light
	var light	= new THREE.HemisphereLight( 0xfffff0, 0x101020, 1.25 );
	light.position.set( 0.75, 1, 0.25 );
	scene.add( light );

  // set up city
  var gen = new URBGEN.Generator();
  var cityGeom;
  var city;
  // set up GUI
      window.onLoad = function() {
        var gui = new dat.GUI();
        gui.width = 300;
        gui.add(gen, "regularity1", 0.3, 0.6).listen();
        gui.add(gen, "regularity2", 0.3, 0.6).listen();
        gui.add(gen, "blockSize", 15000, 50000).listen();
        gui.add(gen, "cityWidth", 200, 1500).listen();
        gui.add(gen, "cityDepth", 200, 1500).listen();
        gui.add(gen, "streetWidth", 10, 30).listen();
        gui.add(gen, "localGrids", 0, 1).listen();
        gui.add(gen, "throughRoads", 0, 50).listen();
        gui.add(this, "update").listen();
        gui.add(this, "random").listen();
        gui.add(this, "export");
        this.update();
      };
  
  window.export = function() {
    exportGeometry();
  };
  
  window.random = function() {
    gen.initRandom();
    gen.generate();
    loadCity();
  };
  
  window.update = function() {
    var d = new Date();
    var start = d.getTime();
    gen.init();
    gen.generate();
    d = new Date();
    var end = d.getTime();
    var elapsed = (end - start) / 1000;
    console.log("City generated in " + elapsed + " seconds");
    console.log("City contains " + gen.buildings.length + " plots");
    loadCity();
  };
  window.onLoad();
  
  function loadCity() {
    scene.remove(city);
    cityGeom = UGDEMO.getCity3D(gen.buildings);
    city = THREE.SceneUtils.createMultiMaterialObject(cityGeom,
      [new THREE.MeshLambertMaterial({color: 0xffffff}),
      new THREE.MeshBasicMaterial({color: 0x000000,
      wireframe: true})]);
    city.rotation.x = -90 * Math.PI / 180;
    var maxX = 0;
    var maxZ = 0;
    for (var i = 0; i < cityGeom.vertices.length; i++) {
      if (cityGeom.vertices[i].x > maxX) maxX = cityGeom.vertices[i].x;
      if (cityGeom.vertices[i].z > maxZ) maxZ = cityGeom.vertices[i].z;
    }
    city.position.x = -maxX / 2;
    city.position.z = maxZ * 7;
    city.position.y = 0;
    scene.add(city)
    //camera.lookAt(city);
  }


	
	// camera controls
	camera.position.x = 0;
	camera.position.z = 0;
	camera.position.y = 600;
	var controls	= new THREE.OrbitControls( camera, renderer.domElement);
	updateFcts.push(function(delta, now){
		controls.update( delta );
	});
	

  // render
	updateFcts.push(function(){
		renderer.render( scene, camera );
	});
	
	// animation loop
	var lastTimeMsec = null;
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60;
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec);
		lastTimeMsec	= nowMsec;
		// call each update function
		updateFcts.forEach(function(updateFn) {
			updateFn(deltaMsec/1000, nowMsec/1000)
		});
	});
	
</script>
</body>
</html>
