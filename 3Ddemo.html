<!DOCTYPE html>
  <head>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/UrbGen.js"></script>
    <script src="js/dat.gui.min.js"></script>
    <script src="js/FileSaver.js"></script>
  </head>
<body>
<script>


	function exportGeometry () {
	  //TODO add this into URBGEN
    var geom = gen.city.geometry;
    var vertices = geom.vertices;
    var faces = geom.faces;
    var output = "";
    for (var v = 0; v < vertices.length; v++) {
      output += "v " + vertices[v][0] + " " + vertices[v][1] + " " + vertices[v][2] + '\n';
    }
    for (var f = 0; f < faces.length; f++) {
      output += "f " + faces[f][0] + " " + faces[f][1] + " " + faces[f][2] + '\n';
    }

		var blob = new Blob( [ output ], { type: 'text/plain' } );
		var objectURL = URL.createObjectURL( blob );
		var date = new Date();
		var timeStamp = date.getTime();
		var fileName = "urbgen_model_" + timeStamp +".obj";
		saveAs(blob, fileName);
	};
	
	function exportParamaters() {
	  var output = ("regularity1: " + gen.regularity1 + ",\n" +
	               "regularity2: " + gen.regularity2 + ",\n" +
	               "blockSize: " + gen.blockSize + ",\n" +
	               "cityWidth: " + gen.cityWidth + ",\n" +
	               "cityDepth: " + gen.cityDepth + ",\n" +
	               "streetWidth: " + gen.streetWidth + ",\n" +
	               "localGrids: " + gen.localGrids + ",\n" +
	               "randomSeed: " + gen.randomSeed + ",\n" +
	               "throughRoads: " + gen.throughRoads
	               );
	
	  var blob = new Blob([output], {type: 'text/plain'});
		var date = new Date();
		var timeStamp = date.getTime();
		var fileName = "urbgen_model_" + timeStamp +".txt";
		saveAs(blob, fileName);
	}
	
	var updateFcts	= [];
	var scene	= new THREE.Scene();
	scene.fog	= new THREE.FogExp2( 0xd0e0f0, 0.002 );
	// add a renderer
	var renderer	= new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setClearColor(0xffffff, 1);
	document.body.appendChild( renderer.domElement );
	// add a camera
	var camera	= new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 2000);
	// add a light
	var light	= new THREE.HemisphereLight( 0xfffff0, 0x101020, 1.25 );
	light.position.set( 0.75, 1, 0.25 );
	scene.add( light );

  // set up city
  var gen = new URBGEN.Generator();
  var cityGeom;
  var city;
  // set up GUI
      window.onLoad = function() {
        var gui = new dat.GUI();
        gui.width = 300;
        gui.add(gen, "cityWidth", 400, 1500).listen();
        gui.add(gen, "cityDepth", 400, 1500).listen();
        gui.add(gen, "blockSize", 15000, 50000).listen();
        gui.add(gen, "streetWidth", 10, 30).listen();
        gui.add(gen, "regularity1", 0.3, 0.6).listen();
        gui.add(gen, "regularity2", 0.3, 0.6).listen();
        gui.add(gen, "localGrids", 0, 1).listen();
        gui.add(gen, "throughRoads", 0, 50).listen();
        gui.add(gen, "randomSeed", 0, 1).listen();
        gui.add(this, "update").listen();
        gui.add(this, "random").listen();
        gui.add(this, "exportOBJ");
        gui.add(this, "exportParams");
        this.update();
      };
  window.exportParams = function() {
    exportParamaters();
  }
  window.exportOBJ = function() {
    exportGeometry();
  };
  
  window.random = function() {
    gen.initRandom();
    gen.generate();
    loadCity();
  };
  
  window.update = function() {
    var d = new Date();
    var start = d.getTime();
    gen.init();
    gen.generate();
    d = new Date();
    var end = d.getTime();
    var elapsed = (end - start) / 1000;
    console.log("City generated in " + elapsed + " seconds");
    console.log("City contains " + gen.city.getPlots().length + " plots");
    loadCity();
  };
  window.onLoad();

  function loadCity() {
    scene.remove(city);
    cityGeom = getCity3D(gen.city.getPlots());
    city = THREE.SceneUtils.createMultiMaterialObject(cityGeom,
      [new THREE.MeshLambertMaterial({color: 0xffffff}),
      new THREE.MeshBasicMaterial({color: 0x000000,
      wireframe: true})]);
    city.rotation.x = -90 * Math.PI / 180;
    var maxX = 0;
    var maxZ = 0;
    for (var i = 0; i < cityGeom.vertices.length; i++) {
      if (cityGeom.vertices[i].x > maxX) maxX = cityGeom.vertices[i].x;
      if (cityGeom.vertices[i].z > maxZ) maxZ = cityGeom.vertices[i].z;
    }
    city.position.x = -maxX / 2;
    city.position.z = maxZ * 7;
    city.position.y = 0;
    scene.add(city)
  }
  
  function getCity3D(plots) {
    var cityGeom = new THREE.Geometry();
    var light = new THREE.Color( 0xffffff );
    var shadow    = new THREE.Color( 0xff6666 );
    for (var j = 0; j < plots.length; j++) {
      var plot = gen.buildThreeShape(plots[j].poly, new THREE.Shape());
      // set the extrusion settings
      var extrusionSettings = {
        size: 30, height: 4, curveSegments: 3,
        bevelThickness: 1, bevelSize: 2, bevelEnabled: false,
        material: 0, extrudeMaterial: 1, amount: plots[j].height
      };
      var blockGeom = new THREE.ExtrudeGeometry(plot, extrusionSettings);
      var value = 1 - Math.random() * Math.random();
      var baseColor   = new THREE.Color().setRGB( value + Math.random() * 0.1, value, value + Math.random() * 0.1 );
      var topColor    = baseColor.clone().multiply( light );
      var bottomColor = baseColor.clone().multiply( shadow );
      for ( var k = 0, kl = blockGeom.faces.length; k < kl; k ++ ) {
        if ( j === 2 ) {
          blockGeom.faces[ k ].vertexColors = [ baseColor, baseColor, baseColor, baseColor ];
        } else {
          blockGeom.faces[ k ].vertexColors = [ topColor, bottomColor, bottomColor, topColor ];
        }
      }
      cityGeom.merge(blockGeom);
    }
    return cityGeom;
  };


	
	// camera controls
	camera.position.x = 0;
	camera.position.z = 0;
	camera.position.y = 600;
	var controls	= new THREE.OrbitControls( camera, renderer.domElement);
	updateFcts.push(function(delta, now){
		controls.update( delta );
	});
	

  // render
	updateFcts.push(function(){
		renderer.render( scene, camera );
	});
	
	// animation loop
	var lastTimeMsec = null;
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60;
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec);
		lastTimeMsec	= nowMsec;
		// call each update function
		updateFcts.forEach(function(updateFn) {
			updateFn(deltaMsec/1000, nowMsec/1000)
		});
	});
	
</script>
</body>
</html>
